# frozen_string_literal: true

default_platform(:android)
fastlane_require 'dotenv'

UI.user_error!('Please run fastlane via `bundle exec`') unless FastlaneCore::Helper.bundler?

USER_ENV_FILE_PATH = File.join(Dir.home, '.simplenoteandroid-env.default')
PROTOTYPE_BUILD_DOMAIN = 'https://d2twmm2nzpx3bg.cloudfront.net'

before_all do
  # TODO: Use EnvManager — https://github.com/wordpress-mobile/release-toolkit/pull/578
  UI.user_error!("#{USER_ENV_FILE_PATH} not found: Please copy env.example to #{USER_ENV_FILE_PATH} and fill in the values") unless is_ci || File.file?(USER_ENV_FILE_PATH)
  Dotenv.load(USER_ENV_FILE_PATH)
end

PROJECT_ROOT_FOLDER = File.dirname(File.expand_path(__dir__))

ORGANIZATION = 'automattic'
REPO_NAME = 'simplenote-android'
GITHUB_REPO = "#{ORGANIZATION}/#{REPO_NAME}".freeze
DEFAULT_BRANCH = 'trunk'
BUILDKITE_ORG = ORGANIZATION
BUILDKITE_PIPELINE = REPO_NAME
APP_PACKAGE_NAME = 'com.automattic.simplenote'

APP_SOURCES_FOLDER = File.join(PROJECT_ROOT_FOLDER, 'Simplenote')
METADATA_FOLDER = File.join(APP_SOURCES_FOLDER, 'metadata')
BUILD_FOLDER = File.join(APP_SOURCES_FOLDER, 'build')
RES_FOLDER = File.join(APP_SOURCES_FOLDER, 'src', 'main', 'res')
MAIN_STRINGS_PATH = File.join(RES_FOLDER, 'values', 'strings.xml')
UPDATE_STRINGS_PATH = File.join(PROJECT_ROOT_FOLDER, 'fastlane', 'resources', 'values')

SUPPORTED_LOCALES = [
  { glotpress: 'ar', android: 'ar', google_play: 'ar', promo_config: {} },
  { glotpress: 'de', android: 'de', google_play: 'de-DE',  promo_config: {} },
  { glotpress: 'es', android: 'es', google_play: 'es-ES',  promo_config: {} },
  { glotpress: 'fr', android: 'fr', google_play: 'fr-FR',  promo_config: {} },
  { glotpress: 'he', android: 'he', google_play: 'iw-IL',  promo_config: {} },
  { glotpress: 'id', android: 'id', google_play: 'id', promo_config: {} },
  { glotpress: 'it', android: 'it', google_play: 'it-IT',  promo_config: {} },
  { glotpress: 'ja', android: 'ja', google_play: 'ja-JP',  promo_config: {} },
  { glotpress: 'ko', android: 'ko', google_play: 'ko-KR',  promo_config: {} },
  { glotpress: 'nl', android: 'nl', google_play: 'nl-NL',  promo_config: {} },
  { glotpress: 'pt-br', android: 'pt-rBR', google_play: 'pt-BR', promo_config: {} },
  { glotpress: 'ru', android: 'ru', google_play: 'ru-RU',  promo_config: {} },
  { glotpress: 'sv', android: 'sv', google_play: 'sv-SE',  promo_config: {} },
  { glotpress: 'tr', android: 'tr', google_play: 'tr-TR',  promo_config: {} },
  { glotpress: 'zh-cn', android: 'zh-rCN', google_play: 'zh-CN',  promo_config: {} },
  { glotpress: 'zh-tw', android: 'zh-rTW', google_play: 'zh-TW',  promo_config: {} }
].freeze

GLOTPRESS_BASE_URL = 'https://translate.wordpress.com/projects'
# URL of the GlotPress project containing the app's strings
#
# Notice the trailing / is required.
# Without it, GlotPress will redirect to the version with /
GLOTPRESS_APP_STRINGS_PROJECT_URL = "#{GLOTPRESS_BASE_URL}/simplenote/android/".freeze
# URL of the GlotPress project containing the Play Store metadata (title, keywords, release notes, …)
GLOTPRESS_STORE_METADATA_PROJECT_URL = "#{GLOTPRESS_APP_STRINGS_PROJECT_URL}release-notes/".freeze

RELEASE_NOTES_SOURCE_PATH = File.join(PROJECT_ROOT_FOLDER, 'RELEASE-NOTES.txt')
RELEASE_NOTES_PATH = File.join(METADATA_FOLDER, 'release_notes.txt')

UPLOAD_TO_PLAY_STORE_JSON_KEY = File.join(PROJECT_ROOT_FOLDER, '.configure-files', 'google-upload-credentials.json')

GRADLE_APK_OUTPUT_PATH = File.join(BUILD_FOLDER, 'outputs', 'apk', 'release', 'Simplenote-release.apk')

VERSION_PROPERTIES_PATH = File.join(PROJECT_ROOT_FOLDER, 'version.properties')

VERSION_CALCULATOR = Fastlane::Wpmreleasetoolkit::Versioning::SemanticVersionCalculator.new
VERSION_FORMATTER = Fastlane::Wpmreleasetoolkit::Versioning::RCNotationVersionFormatter.new
BUILD_CODE_FORMATTER = Fastlane::Wpmreleasetoolkit::Versioning::SimpleBuildCodeFormatter.new
BUILD_CODE_CALCULATOR = Fastlane::Wpmreleasetoolkit::Versioning::SimpleBuildCodeCalculator.new
VERSION_FILE = Fastlane::Wpmreleasetoolkit::Versioning::AndroidVersionFile.new(version_properties_path: VERSION_PROPERTIES_PATH)

platform :android do
  ENV['PROJECT_ROOT_FOLDER'] = "#{File.dirname(File.expand_path(__dir__))}/"
  ENV['PROJECT_NAME'] = 'Simplenote'
  ENV['validate_translations'] = 'buildRelease'
  ENV['FL_RELEASE_TOOLKIT_DEFAULT_BRANCH'] = 'trunk'

  desc 'Creates a new release branch from the current default branch'
  lane :code_freeze do |skip_prechecks: false, skip_confirm: false|
    ensure_git_status_clean unless skip_prechecks || is_ci

    Fastlane::Helper::GitHelper.checkout_and_pull(DEFAULT_BRANCH)

    new_version_with_beta = release_version_for_code_freeze
    new_version_final = release_version_next
    new_build_code = build_code_next

    message = <<~MESSAGE
      Code Freeze:
      - New release branch from #{DEFAULT_BRANCH}: #{release_branch_name(release_version: new_version_final)}
      - Current release version and build code: #{release_version_current} (#{build_code_current}).
      - New beta version and build code: #{new_version_with_beta} (#{new_build_code}).
    MESSAGE
    UI.important(message)

    unless skip_confirm || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
      next
    end

    UI.message 'Creating release branch...'
    Fastlane::Helper::GitHelper.create_branch(release_branch_name(release_version: new_version_final), from: DEFAULT_BRANCH)
    UI.success("Done! New release branch is: #{git_branch}.")

    UI.message 'Bumping beta version and build code...'
    VERSION_FILE.write_version(
      version_name: new_version_with_beta,
      version_code: new_build_code
    )
    commit_version_bump
    UI.success("Done! New beta version: #{release_version_current}. New build code: #{build_code_current}.")

    extract_release_notes_for_version(
      version: new_version_with_beta,
      release_notes_file_path: RELEASE_NOTES_SOURCE_PATH,
      extracted_notes_file_path: RELEASE_NOTES_PATH
    )
    android_update_release_notes(
      new_version: new_version,
      release_notes_file_path: RELEASE_NOTES_SOURCE_PATH
    )

    update_strings_for_translation_automation

    unless skip_confirm || UI.confirm('Ready to push changes to remote to let the automation configure it on GitHub?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
      next
    end

    push_to_git_remote(
      tags: false,
      set_upstream: true
    )

    copy_branch_protection(
      repository: GITHUB_REPO,
      from_branch: DEFAULT_BRANCH,
      to_branch: release_branch_name
    )
    set_milestone_frozen_marker(
      repository: GITHUB_REPO,
      milestone: new_version_final,
      freeze: true
    )
  end

  desc 'Updates the PlayStoreStrings.pot file'
  lane :update_appstore_strings do |version: release_version_current|
    UI.important('This has been renamed to update_play_store_strings – Here only for backwards compatibility with checklists. Will be removed soon.')
    UI.important('Forwarding to update_play_store_strings....')
    update_play_store_strings(version: version)
  end

  desc 'Updates the PlayStoreStrings.pot file'
  lane :update_play_store_strings do |version: release_version_current|
    files = {
      release_note: RELEASE_NOTES_PATH,
      play_store_promo: File.join(METADATA_FOLDER, 'short_description.txt'),
      play_store_desc: File.join(METADATA_FOLDER, 'full_description.txt'),
      play_store_app_title: File.join(APP_SOURCES_FOLDER, 'metadata', 'title.txt')
    }

    pot_path = File.join(METADATA_FOLDER, 'PlayStoreStrings.pot')

    an_update_metadata_source(
      po_file_path: pot_path,
      source_files: files,
      release_version: version
    )

    git_add(path: pot_path)
    git_commit(
      path: pot_path,
      message: "Update `#{File.basename(pot_path)}` for #{version}",
      allow_nothing_to_commit: true
    )
  end

  desc 'Updates a release branch for a new beta release'
  lane :new_beta_release do |skip_confirm: false|
    ensure_git_status_clean
    ensure_git_branch_is_release_branch!

    message = <<~MESSAGE
      New beta release:
      - Current beta version: #{release_version_current}
      - New beta version: #{release_version_next_beta}

      - Current build code: #{build_code_current}
      - New build code: #{build_code_next}
    MESSAGE
    UI.important(message)

    UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.") unless skip_confirm || UI.confirm('Do you want to continue?')

    UI.message 'Bumping beta version and build code...'
    VERSION_FILE.write_version(
      version_name: release_version_next_beta,
      version_code: build_code_next
    )
    commit_version_bump
    # Print computed version and build to let user double-check outcome in logs
    UI.success("Done! New beta version: #{release_version_current}. New build code: #{build_code_current}")

    download_translations
    download_metadata_strings

    UI.important('Pushing changes to remote and triggering the beta build...')
    UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.") unless skip_confirm || UI.confirm('Do you want to continue?')

    push_to_git_remote(tags: false)

    trigger_release_build(branch_to_build: release_branch_name)

    # TODO: Switch to working branch and open back-merge PR
  end

  desc 'Creates a new hotfix branch from the given tag'
  lane :new_hotfix_release do |version_name:, version_code:, skip_confirm: false|
    ensure_git_status_clean

    new_version = version_name
    version_code_new = version_code

    previous_version = VERSION_FORMATTER.release_version(
      VERSION_CALCULATOR.previous_patch_version(version: VERSION_FORMATTER.parse(new_version))
    )

    UI.user_error!("The version `#{new_version}` tag already exists!") if git_tag_exists(tag: new_version)
    UI.user_error!("Version #{previous_version} is not tagged! A hotfix branch cannot be created.") unless git_tag_exists(tag: previous_version)

    message = <<~MESSAGE
      Hotfix release:
      - Current release version: #{release_version_current}
      - New hotfix version: #{new_version}

      - Current build code: #{build_code_current}
      - New build code: #{version_code_new}

      Branching from tag: #{previous_version}
    MESSAGE
    UI.important(message)

    UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.") unless skip_confirm || UI.confirm('Do you want to continue?')

    UI.message('Creating hotfix branch...')
    Fastlane::Helper::GitHelper.create_branch(release_branch_name(release_version: new_version), from: previous_version)
    UI.success("Done! New hotfix branch is: #{git_branch}")

    UI.message('Bumping hotfix version and build code...')
    VERSION_FILE.write_version(
      version_name: new_version,
      version_code: version_code_new
    )
    commit_version_bump
    UI.success("Done! New release version: #{release_version_current}. New build code: #{build_code_current}.")

    UI.important('Pushing new hotfix branch to remote...')
    push_to_git_remote(tags: false)

    # TODO: Switch to working branch and open back-merge PR
  end

  desc 'Finalizes a hotfix release by tagging the build'
  lane :finalize_hotfix_release do |skip_confirm: false|
    ensure_git_status_clean
    ensure_git_branch_is_release_branch!

    hotfix_version = release_version_current

    UI.important("Triggering hotfix build for version: #{hotfix_version}...")
    UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.") unless skip_confirm || UI.confirm('Do you want to continue?')

    trigger_release_build(branch_to_build: release_branch_name)
  end

  desc 'Updates store metadata and runs the release checks'
  lane :finalize_release do |skip_confirm: false|
    UI.user_error!('Please use `finalize_hotfix_release` lane for hotfixes') if android_current_branch_is_hotfix(version_properties_path: VERSION_PROPERTIES_PATH)

    ensure_git_status_clean
    ensure_git_branch_is_release_branch!

    UI.important("Finalizing release: #{release_version_current}")
    UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.") unless skip_confirm || UI.confirm('Do you want to continue?')

    configure_apply(force: is_ci)

    check_translation_progress_all unless is_ci
    download_translations

    UI.message 'Bumping final release version and build code...'
    VERSION_FILE.write_version(
      version_name: release_version_current,
      version_code: build_code_next
    )
    commit_version_bump

    version = release_version_current
    build_code = build_code_current
    UI.success("Done! New release version: #{version}. New build code: #{build_code}.")

    download_metadata_strings(version: version, build_number: build_code)

    remove_branch_protection(
      repository: GITHUB_REPO,
      branch: release_branch_name
    )
    set_milestone_frozen_marker(
      repository: GITHUB_REPO,
      milestone: version,
      freeze: false
    )
    close_milestone(
      repository: GITHUB_REPO,
      milestone: version
    )
  end

  lane :check_translation_progress_all do
    check_translation_progress_strings
    check_translation_progress_release_notes
  end

  lane :check_translation_progress_strings do
    UI.message('Checking app strings translation status...')
    check_translation_progress(
      glotpress_url: GLOTPRESS_APP_STRINGS_PROJECT_URL,
      abort_on_violations: false
    )
  end

  lane :check_translation_progress_release_notes do
    UI.message('Checking release notes strings translation status...')
    check_translation_progress(
      glotpress_url: GLOTPRESS_STORE_METADATA_PROJECT_URL,
      abort_on_violations: false
    )
  end

  desc 'Builds and updates for distribution'
  lane :build_pre_releases do |skip_confirm: false, create_release: true|
    # android_build_prechecks(
    #   skip_confirm: skip_confirm,
    #   alpha: false,
    #   beta: true,
    #   final: false
    # )
    #
    # ^ Disabled because fails with the following (regardless of the values of skip_confirm)
    #
    # [20:36:39]: -------------------------------------
    # [20:36:39]: --- Step: android_build_prechecks ---
    # [20:36:39]: -------------------------------------
    # [20:36:39]: $ git symbolic-ref -q HEAD
    # [20:36:39]: ▸ refs/heads/release/2.33
    # [20:36:39]: DEPRECATED: The PROJECT_ROOT_FOLDER environment variable and config item are deprecated and will be removed in a future version of the Release Toolkit...
    # [20:36:39]: DEPRECATED: The PROJECT_NAME environment variable and config item are deprecated and will be removed in a future version of the Release Toolkit...
    # [20:36:39]: Building version 2.33-rc-1(167) (for upload to Beta Channel)
    #
    # [20:36:39]: Unknown method 'options'
    # +-----------------------------------------------+
    # |                 Lane Context                  |
    # +------------------+----------------------------+
    # | DEFAULT_PLATFORM | android                    |
    # | PLATFORM_NAME    | android                    |
    # | LANE_NAME        | android build_pre_releases |
    # +------------------+----------------------------+
    # [20:36:39]: Called from Fastfile at line 286
    # [20:36:39]: ```
    # [20:36:39]:     284:	  desc 'Builds and updates for distribution'
    # [20:36:39]:     285:	  lane :build_pre_releases do |skip_confirm: false, create_release: true|
    # [20:36:39]:  => 286:	    android_build_prechecks(
    # [20:36:39]:     287:	      skip_confirm: skip_confirm,
    # [20:36:39]:     288:	      alpha: false,
    # [20:36:39]: ```
    # [20:36:39]: To call another action from an action use `other_action.options` instead
    # [20:36:39]: fastlane finished with errors
    #
    # [!] To call another action from an action use `other_action.options` instead
    build_and_upload_beta(
      skip_prechecks: true,
      skip_confirm: skip_confirm,
      create_release: create_release
    )
  end

  desc 'Builds and updates for distribution'
  lane :build_and_upload_beta do |skip_prechecks: false, create_release: true|
    unless skip_prechecks
      ensure_git_status_clean
      ensure_git_branch_is_release_branch!
    end

    # We want the full version name, including the rc prefix
    version = VERSION_FILE.read_version_name

    build_and_upload_apk(
      version: version,
      upload_track: 'beta'
    )

    create_gh_release(version: version, prerelease: true) if create_release
  end

  desc 'Builds and updates for distribution'
  lane :build_and_upload_release do |options|
    android_build_prechecks(
      skip_confirm: options[:skip_confirm],
      alpha: false,
      beta: false,
      final: true
    )

    # Create the file names
    version = android_get_release_version
    build_and_upload_apk(
      version: version,
      upload_track: 'production'
    )

    create_gh_release(version: version) if options[:create_release]
  end

  # TODO: Drop build_number like https://github.com/wordpress-mobile/WordPress-Android/pull/21103
  desc 'Downloads translated metadata from GlotPress'
  lane :download_metadata_strings do |version: release_version_current, build_number: build_code_current|
    values = version.split('.')
    files = {
      "release_note_#{values[0].to_s.rjust(2, '0')}#{values[1]}" => { desc: "changelogs/#{build_number}.txt", max_size: 0 },
      play_store_promo: { desc: 'short_description.txt', max_size: 80 },
      play_store_desc: { desc: 'full_description.txt', max_size: 0 },
      play_store_app_title: { desc: 'title.txt', max_size: 50 }
    }

    delete_old_changelogs(build: build_number)
    download_path = "#{Dir.pwd}/metadata/android"
    gp_downloadmetadata(
      project_url: GLOTPRESS_STORE_METADATA_PROJECT_URL,
      target_files: files,
      locales: SUPPORTED_LOCALES.map { |hsh| [hsh[:glotpress], hsh[:google_play]] },
      source_locale: 'en-US',
      download_path: download_path
    )

    # TODO: These two can be removed once we have a lane to upload the metadata to the Google Play Store.
    #       upload_to_play_store uses the individual changelos without needing a merged one.
    android_create_xml_release_notes(
      download_path: download_path,
      build_number: build_number.to_s,
      locales: SUPPORTED_LOCALES.to_h { |hsh| [hsh[:glotpress], hsh[:google_play]] }
    )
    add_us_release_notes(
      release_notes_path: File.join(download_path, 'release_notes.xml'),
      version_name: version
    )

    # We need to explicitly call `git_add`, despite the path being passed to `git_commit` as well.
    # That's because we might have new files, that the commit command would otherwise miss.
    git_add(path: download_path)
    git_commit(
      path: download_path,
      message: "Update metadata translations for #{version}",
      allow_nothing_to_commit: true
    )
  end

  desc 'Download the latest app translations from GlotPress and update the strings.xml files accordingly'
  lane :download_translations do
    # android_update_release_notes requires a relative path
    res_folder_relative_path = RES_FOLDER.gsub(PROJECT_ROOT_FOLDER, '')

    android_download_translations(
      res_dir: res_folder_relative_path,
      glotpress_url: GLOTPRESS_APP_STRINGS_PROJECT_URL,
      locales: SUPPORTED_LOCALES,
      lint_task: 'lintRelease'
    )
  end

  desc 'Builds an app apk and upload it'
  lane :build_and_upload_apk do |version: release_version_current, build_code: build_code_current, upload_track: nil|
    user_friendly_output_dir = File.join(PROJECT_ROOT_FOLDER, 'build')
    user_friendly_output_apk_name = "simplenote-#{version}.apk"
    user_friendly_output_path = File.join(user_friendly_output_dir, user_friendly_output_apk_name)

    build_type = 'Release'

    UI.message('Cleaning build folder...')
    gradle(task: 'clean')

    UI.message('Linting...')
    gradle(task: 'lint', build_type: build_type)

    UI.message("Building #{version} (#{build_code}) to #{user_friendly_output_path}...")
    gradle(task: 'assemble', build_type: build_type)
    FileUtils.copy(GRADLE_APK_OUTPUT_PATH, user_friendly_output_path)

    if File.exist? user_friendly_output_path
      UI.success("APK ready at #{user_friendly_output_path}")
    else
      UI.user_error!("Unable to find a build artifact at #{user_friendly_output_path}")
    end

    if upload_track.nil?
      UI.message('Skipping upload to Google Play Console because on `upload_track` given.')
    else
      upload_to_play_store(
        package_name: APP_PACKAGE_NAME,
        apk: user_friendly_output_path,
        track: upload_track,
        release_status: 'draft',
        skip_upload_metadata: true,
        skip_upload_changelogs: true,
        skip_upload_images: true,
        skip_upload_screenshots: true,
        json_key: UPLOAD_TO_PLAY_STORE_JSON_KEY
      )
    end

    user_friendly_output_path
  end

  desc 'Build a Prototype Build and make it available for download'
  lane :build_and_upload_prototype_build do
    UI.user_error!("'BUILDKITE_ARTIFACTS_S3_BUCKET' must be defined as an environment variable.") unless ENV['BUILDKITE_ARTIFACTS_S3_BUCKET']

    prototype_build_type = 'Debug'

    gradle(
      task: 'assemble',
      build_type: prototype_build_type
    )

    filename = "simplenote-android-prototype-build-#{generate_prototype_build_number}.apk"

    upload_path = upload_to_s3(
      bucket: 'a8c-apps-public-artifacts',
      key: filename,
      file: lane_context[SharedValues::GRADLE_APK_OUTPUT_PATH]
    )

    return if ENV['BUILDKITE_PULL_REQUEST'].nil?

    install_url = "#{PROTOTYPE_BUILD_DOMAIN}/#{upload_path}"

    unless ENV['BUILDKITE_PULL_REQUEST'].nil?
      comment_body = prototype_build_details_comment(
        app_display_name: 'Simplenote Android',
        download_url: install_url,
        metadata: {
          'Build Type': prototype_build_type
        }
      )

      comment_on_pr(
        project: GITHUB_REPO,
        pr_number: Integer(ENV.fetch('BUILDKITE_PULL_REQUEST', nil)),
        reuse_identifier: 'simplenote-prototype-build-link',
        body: comment_body
      )
    end

    if ENV['BUILDKITE']
      message = "Simplenote Android Prototype Build: [#{filename}](#{install_url})"
      sh('buildkite-agent', 'annotate', message, '--style', 'info', '--context', 'prototype-build')
    end
  end

  desc 'Trigger a release build on Buildkite'
  lane :trigger_release_build do |branch_to_build: git_branch|
    UI.important("There will be no release build from #{branch_to_build}.")
    UI.important('We do not yet have automated Builkite relaeses in this project!')
    UI.important('You will need to build the app binary and upload it manually')
    # buildkite_trigger_build(
    #   buildkite_organization: BUILDKITE_ORG,
    #   buildkite_pipeline: BUILDKITE_PIPELINE,
    #   branch: branch_to_build,
    #   pipeline_file: 'release-builds.yml'
    # )
  end

  desc 'Take screenshots in the app'
  lane :take_screenshots do
    package = "#{APP_PACKAGE_NAME}.debug"

    # Reset the app in the emulator, just to avoid possible state related
    # issues
    begin
      adb(command: "shell pm clear #{package}")
    rescue StandardError
      UI.message('Failed to reset app data on emulator. This can happen when the app is not installed yet.')
    end

    # We use the screenshots build type for the app APK, which allows us to not
    # set the special permissions in the debug build type so that it doesn't
    # deviate from the release one. For the test APK though, we still use the
    # debug build type, as it's the only testable one, and there's no need to
    # make a dedicated one for the screenshots.
    gradle(task: 'assemble', build_type: 'Screenshots')
    gradle(task: 'assemble', build_type: 'DebugAndroidTest')

    capture_android_screenshots(
      locales: ['en-US'],
      output_directory: screenshots_directory,
      clear_previous_screenshots: false,
      app_package_name: package,
      app_apk_path: File.join(BUILD_FOLDER, 'outputs', 'apk', 'screenshots', 'Simplenote-screenshots.apk'),
      tests_apk_path: File.join(BUILD_FOLDER, 'outputs', 'apk', 'androidTest', 'debug', 'Simplenote-debug-androidTest.apk'),
      # Because the screenshot tests are together with other UI tests, we need
      # to specify to run only them and not all of the others.
      use_tests_in_classes: "#{APP_PACKAGE_NAME}.screenshots.ScreenshotTest",
      use_timestamp_suffix: false,
      # Need to use this in order to get access to the screenshots on the
      # emulator. Also note that you might need to run on a Google API
      # emulator, that is one without the Play Store. See
      # https://github.com/fastlane/fastlane/issues/15788#issuecomment-583778278
      use_adb_root: true
    )
  end

  def screenshots_directory
    File.join(Dir.pwd, 'screenshots')
  end

  private_lane :delete_old_changelogs do |options|
    Dir.glob('./metadata/android/*/').each do |folder|
      Dir["#{folder}changelogs/*"].each do |file|
        File.delete(file) if Integer(File.basename(file, '.*')) < Integer(options[:build])
      rescue StandardError
        puts "Cannot delete file #{file}"
      end
    end
  end

  private_lane :add_us_release_notes do |options|
    en_release_notes_path = File.join(METADATA_FOLDER, 'release_notes.txt')
    File.open(options[:release_notes_path], 'a') do |f|
      f.puts('<en-US>')
      f.puts("#{options[:version_name]}:")
      f.puts(File.read(en_release_notes_path))
      f.puts('</en-US>')
    end
  end

  private_lane :update_strings_for_translation_automation do
    sh("cd .. && mkdir -p #{UPDATE_STRINGS_PATH} && cp #{MAIN_STRINGS_PATH} #{UPDATE_STRINGS_PATH}")
    strings_path = File.join(UPDATE_STRINGS_PATH, 'strings.xml')
    git_commit(
      path: strings_path,
      message: 'Update strings file for translation automation',
      allow_nothing_to_commit: true
    )
  end

  private_lane :create_gh_release do |version:, prerelease: false|
    # TODO: Add step to downalod universal APK etc. once the app uses bundles

    create_release(
      repository: GITHUB_REPO,
      version: version,
      release_notes_file_path: RELEASE_NOTES_PATH,
      prerelease: prerelease,
      release_assets: GRADLE_APK_OUTPUT_PATH.to_s
    )
  end

  # This function is Buildkite-specific
  def generate_prototype_build_number
    if ENV['BUILDKITE']
      commit = ENV.fetch('BUILDKITE_COMMIT', nil)[0, 7]
      branch = ENV['BUILDKITE_BRANCH'].parameterize
      pr_num = ENV.fetch('BUILDKITE_PULL_REQUEST', nil)

      pr_num == 'false' ? "#{branch}-#{commit}" : "pr#{pr_num}-#{commit}-#{ENV.fetch('BUILDKITE_JOB_ID', nil)}"
    else
      repo = Git.open(PROJECT_ROOT_FOLDER)
      commit = repo.current_branch.parameterize
      branch = repo.revparse('HEAD')[0, 7]

      "#{branch}-#{commit}"
    end
  end
end

def release_version_current
  current_version = VERSION_FORMATTER.parse(VERSION_FILE.read_version_name)
  VERSION_FORMATTER.release_version(current_version)
end

def release_version_next
  current_version = VERSION_FORMATTER.parse(VERSION_FILE.read_version_name)
  release_version_next = VERSION_CALCULATOR.next_release_version(version: current_version)
  VERSION_FORMATTER.release_version(release_version_next)
end

# Compute the version to be used by the code freeze step in the release process.
#
# It first increments the minor number, which also resets the build number to 0.
# It then bumps the build number so the -rc-1 can be appended to the code freeze version.
def release_version_for_code_freeze
  current_version = VERSION_FORMATTER.parse(VERSION_FILE.read_version_name)
  next_version = VERSION_CALCULATOR.next_release_version(version: current_version)
  beta_version_first = VERSION_CALCULATOR.next_build_number(version: next_version)
  VERSION_FORMATTER.beta_version(beta_version_first)
end

def release_version_next_beta
  current_version = VERSION_FORMATTER.parse(VERSION_FILE.read_version_name)
  beta_version_next = VERSION_CALCULATOR.next_build_number(version: current_version)
  VERSION_FORMATTER.beta_version(beta_version_next)
end

def build_code_current
  build_code_current = VERSION_FILE.read_version_code
  BUILD_CODE_FORMATTER.build_code(build_code: build_code_current)
end

def build_code_next
  build_code_current = VERSION_FILE.read_version_code
  build_code_next = BUILD_CODE_CALCULATOR.next_build_code(build_code: build_code_current)
  BUILD_CODE_FORMATTER.build_code(build_code: build_code_next)
end

def commit_version_bump
  git_commit(
    path: VERSION_PROPERTIES_PATH,
    message: 'Bump version name and code',
    allow_nothing_to_commit: false
  )
end

def release_branch_name(release_version: release_version_current)
  "#{RELEASE_BRANCH_ROOT}#{release_version}"
end

def ensure_git_branch_is_release_branch!
  # Verify that the current branch is a release branch.
  # Notice that `ensure_git_branch` expects a RegEx parameter.
  # Also, ensure_git_branch will fail the lane if the branch doesn't match, hence the ! in the method name.
  ensure_git_branch(branch: "^#{RELEASE_BRANCH_ROOT}")
end

RELEASE_BRANCH_ROOT = 'release/'
